# Understanding RIDs and UXML Re-Import

## What are RIDs?

**RID** = **Reference ID** in Unity's `ManagedReferencesRegistry`

### The Three-Way Relationship:

```
RID (1000)  ←→  uxmlAssetId (-1320750867)  ←→  Element m_Id (-1320750867)
   ↓                      ↓                              ↓
Binding Data      Links binding to element      The actual UI element
```

## Key Insights

### 1. RIDs are Sequential
- Start at 1000 (by convention)
- Increment by 1 for each binding: 1000, 1001, 1002, 1003...
- **Sequential within a single UXML file**
- **NOT globally unique** across different files

### 2. Element m_Ids are Hash-Based
- Values like: `-1320750867`, `382705796`, `-701132486`
- **NOT sequential** - appear to be hash values
- **Stable** - same element gets same m_Id when Unity regenerates
- **Generated by Unity** based on element properties (type, name, position)

### 3. uxmlAssetId Links Them
- Field in the binding's serialized data
- **Must match** the element's m_Id
- This is how Unity knows which element the binding applies to

## The Problem with Layout Changes

### Scenario 1: Adding a New Element (SAFE)

**Before**:
```xml
<!-- BINDING[rid=1000]: ... -->
<BindingRemapper>  <!-- m_Id=-1320750867 -->
  <!-- BINDING[rid=1001]: ... -->
  <VisualElement>  <!-- m_Id=-250374529 -->
  </VisualElement>
</BindingRemapper>
```

**After adding new element**:
```xml
<!-- BINDING[rid=1000]: ... -->
<BindingRemapper>  <!-- m_Id=-1320750867 -->
  <VisualElement>  <!-- NEW: m_Id=??? -->
  </VisualElement>
  <!-- BINDING[rid=1001]: ... -->
  <VisualElement>  <!-- m_Id=-250374529 -->
  </VisualElement>
</BindingRemapper>
```

**Impact**: ✅ Safe
- Existing RIDs stay the same (1000, 1001)
- Existing uxmlAssetIds stay the same
- New element gets a new m_Id (Unity will generate it)
- If new element needs bindings, assign new RID (e.g., 1036)

### Scenario 2: Removing an Element (SAFE with cleanup)

**Before**:
```xml
<!-- BINDING[rid=1000]: ... -->
<BindingRemapper>
  <!-- BINDING[rid=1001]: ... -->
  <VisualElement>  <!-- DELETING THIS -->
  </VisualElement>
  <!-- BINDING[rid=1002]: ... -->
  <VisualElement>
  </VisualElement>
</BindingRemapper>
```

**After**:
```xml
<!-- BINDING[rid=1000]: ... -->
<BindingRemapper>
  <!-- BINDING[rid=1002]: ... -->
  <VisualElement>
  </VisualElement>
</BindingRemapper>
```

**Impact**: ✅ Safe
- Remove binding with rid=1001 from header
- Keep rid=1002 (don't renumber!)
- Gap in RID sequence is fine (1000, 1002, 1003...)

### Scenario 3: Reordering Elements (SAFE)

**Before**:
```xml
<!-- BINDING[rid=1000]: TextBinding: Player.Name -->
<SIText name="player-name">
<!-- BINDING[rid=1001]: TextBinding: Player.Age -->
<SIText name="player-age">
```

**After**:
```xml
<!-- BINDING[rid=1001]: TextBinding: Player.Age -->
<SIText name="player-age">
<!-- BINDING[rid=1000]: TextBinding: Player.Name -->
<SIText name="player-name">
```

**Impact**: ✅ Safe
- Element m_Ids don't change
- uxmlAssetIds in bindings don't change
- RIDs don't change
- Just visual reordering in XML

### Scenario 4: Changing Element Properties (DEPENDS)

**Before**:
```xml
<!-- BINDING[rid=1000]: TextBinding: Player.Name -->
<SIText name="player-name" class="heading">
```

**After changing class**:
```xml
<!-- BINDING[rid=1000]: TextBinding: Player.Name -->
<SIText name="player-name" class="body">
```

**Impact**: ✅ Safe
- Changing CSS classes doesn't affect m_Id
- Binding stays linked

**After changing name**:
```xml
<!-- BINDING[rid=1000]: TextBinding: Player.Name -->
<SIText name="player-fullname" class="heading">
```

**Impact**: ⚠️ **RISKY**
- Element name might affect m_Id generation in Unity
- If m_Id changes, uxmlAssetId link breaks
- **Solution**: Update uxmlAssetId in binding data to new m_Id

**After changing type**:
```xml
<!-- BINDING[rid=1000]: TextBinding: Player.Name -->
<Label name="player-name" class="heading">
```

**Impact**: ❌ **BREAKS**
- Different element type = different m_Id
- Binding type might not match (SIText bindings on Label won't work)
- **Must create new binding** with appropriate type

## What Happens on Re-Import

### Unity's Import Process:

1. **Parse UXML XML** → Extract elements with their types, names, classes
2. **Generate m_Ids** → Unity recalculates hash-based IDs for each element
3. **Parse Binding Comments** → Extract binding data with RIDs
4. **Match Bindings to Elements** → Use uxmlAssetId to find element
5. **Validate** → Check if uxmlAssetId matches any element m_Id
6. **Rebuild ManagedReferencesRegistry** → Create RefIds array with bindings

### If uxmlAssetId doesn't match any element:

**Unity will**:
- Issue a warning (in Unity Editor console)
- Drop the orphaned binding
- Element renders without data connection

**FM will**:
- UI shows blank/default text
- Interactive elements may not work
- No crash, just missing data

## Re-Import Strategy

### Option 1: Preserve Element m_Ids (RECOMMENDED)

When exporting, include element m_Ids in XML:

```xml
<!-- BINDING[rid=1000, uxmlAssetId=-1320750867]: TextBinding: Player.Name -->
<SIText name="player-name" unity:m_Id="-1320750867">
```

On import:
- Read `unity:m_Id` attribute
- Use that exact m_Id instead of generating new one
- Bindings automatically stay linked

**Pros**:
- ✅ Zero binding maintenance
- ✅ Safe for all layout changes
- ✅ Easy to implement

**Cons**:
- ⚠️ Unity might not respect custom m_Ids (need to test)
- ⚠️ Hash collisions possible if manually editing

### Option 2: Rebuild Bindings by Element Match (COMPLEX)

Match bindings to elements by:
1. Element type (e.g., `SI.Bindable.SIText`)
2. Element name (if present)
3. Position in hierarchy

**Pros**:
- ✅ Works with Unity's m_Id generation
- ✅ Handles renamed elements

**Cons**:
- ❌ Complex matching algorithm
- ❌ Ambiguous for unnamed elements
- ❌ Fails if hierarchy changes significantly

### Option 3: Manual RID Management (SAFEST)

**Rules for modders**:

1. **Adding elements**:
   - Find highest RID in file (e.g., 1035)
   - New binding gets next RID (1036)
   - Add to both header and inline

2. **Removing elements**:
   - Delete binding from header
   - Delete inline comment
   - Leave gap in RID sequence

3. **Changing element type**:
   - Delete old binding (with old RID)
   - Create new binding (with new RID and new type)
   - Update uxmlAssetId will be set by Unity

4. **Moving elements**:
   - Keep RIDs unchanged
   - Just move XML and inline comments together

## Example Re-Import Workflow

### Export:
```python
# During export
element_data = {
    'm_Id': -1320750867,
    'm_FullTypeName': 'SI.Bindable.SIText',
    'm_Name': 'player-name'
}

binding_data = {
    'rid': 1000,
    'uxmlAssetId': -1320750867,  # Links to element
    'TextBinding': 'Player.Name'
}

# Write to XML
xml = f'''
<!-- BINDING[rid=1000, uxmlAssetId={binding_data['uxmlAssetId']}]:
     TextBinding: {binding_data['TextBinding']} -->
<SIText name="{element_data['m_Name']}"
        unity:element_id="{element_data['m_Id']}">
'''
```

### Import:
```python
# Parse XML
element = parse_xml_element(xml)
element_type = element.tag  # 'SIText'
element_name = element.get('name')  # 'player-name'
unity_element_id = element.get('unity:element_id')  # -1320750867

# Parse binding comment
binding = parse_binding_comment(preceding_comment)
rid = binding['rid']  # 1000
declared_uxml_id = binding['uxmlAssetId']  # -1320750867

# Strategy 1: Use declared m_Id
if unity_element_id:
    element_m_id = int(unity_element_id)
else:
    # Strategy 2: Let Unity generate
    element_m_id = generate_element_id(element_type, element_name, hierarchy)

# Update binding to point to actual element
binding_data = {
    'rid': rid,
    'uxmlAssetId': element_m_id,  # Use actual element m_Id
    'TextBinding': {
        'm_path': 'Player.Name'
    }
}

# If declared_uxml_id != element_m_id, warn user
if declared_uxml_id != element_m_id:
    print(f'Warning: Binding rid={rid} uxmlAssetId changed')
    print(f'  Old: {declared_uxml_id}')
    print(f'  New: {element_m_id}')
```

## Testing Strategy

To verify binding preservation:

1. **Export** UXML from bundle
2. **Modify** layout (add/remove/reorder elements)
3. **Re-import** into Unity project
4. **Check** Unity Editor console for binding warnings
5. **Test** in-game - verify data displays correctly
6. **Export** again and compare bindings

## Recommendations

### For Skin Modders:

1. **Don't change RIDs** - they're just labels
2. **Don't change uxmlAssetId** in comments - Unity manages this
3. **Keep bindings with their elements** when moving XML
4. **Delete bindings** when deleting bound elements
5. **Use element names** to make matching easier
6. **Test in-game** after significant changes

### For Tool Developers:

1. **Export element m_Ids** in XML (as `unity:element_id`)
2. **Preserve m_Ids on import** if possible
3. **Implement binding validation** - check uxmlAssetId exists
4. **Support binding regeneration** - match by type+name if m_Id changes
5. **Log binding changes** - show what got relinked
6. **Provide binding inspector** - visualize binding connections

## RID Best Practices

### Good:
```xml
<!-- Original file has bindings 1000-1035 -->

<!-- Add new element with new binding -->
<!-- BINDING[rid=1036]: TextBinding: Player.Position -->
<SIText name="position">
```

### Bad:
```xml
<!-- Original file has bindings 1000-1035 -->

<!-- DON'T reuse RID from deleted binding -->
<!-- BINDING[rid=1001]: TextBinding: Player.Position -->
<SIText name="position">

<!-- This creates confusion if old binding data still in registry -->
```

### Good:
```xml
<!-- After deleting binding 1015, leave gap -->
<!-- RIDs: 1000, 1001, 1002, 1016, 1017 -->
```

### Bad:
```xml
<!-- DON'T renumber to fill gaps -->
<!-- Old: 1016 becomes 1015, 1017 becomes 1016 -->
<!-- This breaks all binding comments! -->
```

## Summary

**RIDs are**:
- ✅ Sequential numbers within a file (1000, 1001, 1002...)
- ✅ Just labels in the ManagedReferencesRegistry
- ✅ Safe to have gaps (1000, 1002, 1003 is fine)

**uxmlAssetId is**:
- ✅ The critical link between binding and element
- ✅ Must match element's m_Id
- ⚠️ May change if element properties change

**For safe re-import**:
1. Preserve element m_Ids in XML
2. Match bindings to elements by m_Id
3. Regenerate uxmlAssetId if element m_Id changes
4. Validate all bindings have matching elements
5. Keep RIDs unchanged (don't renumber)

**The golden rule**:
> **If the element's m_Id changes, update the binding's uxmlAssetId to match. Everything else can stay the same.**
